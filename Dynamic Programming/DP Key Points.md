# DP Key Points

## 什么是动态规划(Dynamic Programming)
- 动态规划是一种求最优解的方法
  - 通过吧原问题分解为相对简单的子问题进行求解的方式来求解复杂问题
- 基本思想：
  - 如果要解一个给定的问题，需要解其中不同的子问题，再根据子问题的解得出原问题
  
## 动态规划求解问题的类型
- **求目标函数的最值（最大值/最小值**）
- 判断某个条件是否可行
- 统计满足某个条件的方案数

## 动态规划求解问题的性质
- 通常来说，动态规划需要满足3个性质
- 最优子结构性质：
  - 一个问题的最优解包含它的子问题的最优解，也就是说，可以通过求解子问题的最优解来得到原问题的最优解
- 无后效性性质：
  - 当前的解决只与之前的状态有关，不受未来状态的影响
- 重叠子问题性质
  - 不同的子问题可能会有重复的部分，可以通过记忆化搜索（剪枝pruning）来避免重复计算
  
## 动态规划求解问题的步骤
- 确定状态
  - dp里存的每个状态的定义
  - 初始化
- 状态转移方程(State Transfer Function)
  - 确认每一种状态做出的选择
  - 在背包问题里：
    - 选择物品
    - 不选择物品
  - 状态转移方程通常是一个递推表达式，需要不断滚动(Rolling)
- 需要确定初始条件和边界情况
  - 初始条件通常是说递推的起点
  - 在递推的过程中需要考虑边界情况（特殊情况）
- 确认dp的计算顺序
  - 顺序求解
  - 逆序求解
- 消除冗余
  - 如通过剪纸(pruning)提高性能和计算效率

## 划分型动态规划
- 划分型动态规划是指吧给定的序列或字符串分为若干段，段数不限，每一段满足一定的性质
- 求其中的最值或满足条件的计数
- 状态转移方程
  - 划分型动态规划的状态转移方程通常**不依赖**相邻的位置(ex:dp[i] = max(dp[i - 1]), dp[i - 2])
  - 而是依赖满足划分/添加的位置或者划分的方式


## 背包问题(01背包和完全背包)
- 这两种问题的描述都是：给定一个有限容量的背包，和一些有不同重量的物品，如何选择物品放入背包，使背包的总价值最大
- **根本区别在于**：每种物品的可选择次数
- ex：有n个物品，每个物品的重量为 w = [2, 1, 5, 7]，每个物品的价值为v = [1, 3, 5, 7],背包的总重量为W = 10，问怎么拿能保证价值最大化
  - 如果是01背包，则每个物品只可以拿1次
  - 如果是完全背包，则每个物品可以拿无限次
- **01背包**
  - 状态定义: `dp[i][j]`表示只考虑前i件物品，在背包容量为j时，能获得的最大价值
  - 状态转移方程: `dp[i][j] = dp[i - 1][j]`(不拿第i件物品) `dp[i][j] = dp[i - 1][j - w[i]] + v[i]`(选择拿第i件物品)
  - 因此，合并2种情况`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])`(当j>= w时)
  - 空间优化
    - 用一维数组dp[j]表示容量为j的背包能获得的最大价值
    - 状态转移方程:
      - `dp[j] = max(dp[j], dp[j - w[i]] + v[i])`
      - **在处理j时，需要逆序处理/枚举**
      - 为什么逆序枚举，因为dp[j - w[i]]代表的是上一轮，i-1时候的状态，如果正序枚举，那么dp[j - w[i]可能已经被本轮i更新过了，这就意味着我们重复使用了第i件物品，所以这就变成了完全背包的逻辑。但是在使用逆序更新时，可以保证在更新dp[j]时，dp[j - w[i]还是基于旧的状态
      - ```Python
          for i in range(len(w)):
            for j in range(len(v) - 1, -1, -1):
              if j <= W:
                dp[j] =  max(dp[j], dp[j - w[i]] + v[i])
          ```

- **完全背包问题**
  - 问题描述
    - 有一个容量为W的背包，有N种物品，每种物品的重量是w[i]，价值是v[i]
    - **每种物品都可以无限次使用**
  - 状态定义:
    - `dp[i][j]`表示只考虑前i件物品，在背包容量为j时，能获得的最大价值
  - 状态转移方程
    - 不选第i件物品: 
      - `dp[i][j] = dp[i - 1][j]`
    - 再选一件第i件物品
      - `dp[i][j] = dp[i][j - w[i]] + v[i]`
    - 合并2种情况
      - `dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i])`(当j>= w时)
  - 空间优化
    - 可以用一维数组dp[j]优化
    - `dp[j]= max(dp[j], dp[j - w[i]] +v[i])`
    - - **在处理j时，需要正序处理/枚举**
    - 为什么可以正序枚举
      - 因为`dp[j - w[i]`代表的是当前轮的状态(i时)的状态，正序更新时要计算dp[j]， dp[j - w[i]可能因为放了第i件物品已经被更新过了，这个正好可以让我们重复选同一个物品，此时dp[j - w[i]] +v[i]就变味了在j- v[i]的情况下再加一件i
  - 完全背包的组合和排列
    - 在完全背包中，如果求的是排列数（达到目标target即可，每个物品可以重复选择，且顺序重要， [1, 1, 2]、[1, 2, 1] 和 [2, 1, 1] 被视为不同的情况。），就是外层for循环遍历背包容量，内层for循环物品
      - ex：Leetcode 377
    - 如果求的是组合数（顺序不重要，1, 1, 2] 和 [2, 1, 1] 被视为同一种情况。），就是外层for循环遍历物品，内层for循环遍历背包容量
      - ex：Leetcode 518
- 完全背包和01背包的关键区别在于
  - 在01背包中，选了第i件物品1件后，状态需要退回到i-1，因为物品没了
  - 在完全背包中，，选了第i件物品后，背包容量减少了，但第i件物品依然可以选择，因为状态来源于dp[i][j - w[i]]

|              | 01背包                                                             | 完全背包                                                           |
|--------------|---------------------------------------------------------------------|---------------------------------------------------------------------|
| 状态定义       | 每件物品唯一，最多选1次                                               | 每种物品无限供应，可选任意次                                           |
| 核心区别（状态转移方程） | `dp[i][j]`：前i件物品，容量为j的最大价值                               | `dp[i][j]`：前i种物品，容量为j的最大价值                               |
| 状态来源       | `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])` (当 j >= w[i] 时) | `dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i])` (当 j >= w[i] 时) |
| 一维化实现     | 对容量 j 进行逆序枚举                                                 | 对容量 j 进行正序枚举                                                 |
| 状态转移方程（一维dp） | `dp[j] = max(dp[j], dp[j - w[i]] + v[i])` (逆序处理 j)                 | `dp[j] = max(dp[j], dp[j - w[i]] + v[i])` (正序处理 j)                 |
| 物理意义       | 逆序保证了 `dp[j - w[i]]` 是旧状态，防止被重复迭代                       | 正序利用了 `dp[j - w[i]]` 是新状态，允许重复迭代                        |